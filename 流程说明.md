# AI 图像生成服务开发流程说明

## 📖 概述

本文档详细说明了基于 Cloudflare Workers AI 的完整图像生成服务架构，为开发人员提供新模型集成的标准流程和最佳实践。无论集成任何第三方AI服务，都应遵循此架构模式以确保系统的一致性、可靠性和用户体验。

## 🏗️ 核心架构原则

### 1. **统一接口设计**
- 所有图像生成模型必须实现相同的函数签名
- 返回格式必须标准化为 `data:image/[type];base64,[data]`
- 配置参数采用统一的结构化格式

### 2. **渐进增强策略**  
- 基础功能优先，高级功能可选
- 向下兼容，新功能不影响现有流程
- 智能降级，确保服务可用性

### 3. **用户体验导向**
- 立即响应原则（HTTP 202 Accepted）
- 实时进度反馈
- 错误信息用户友好

---

## 📋 完整开发流程

## 阶段一：配置验证与准备（必须实现）

### 1.1 配置系统设计

**统一配置结构**
```typescript
interface ImageConfig {
  provider: string;              // 服务提供商标识
  apiKey: string;               // API密钥（必需）
  baseUrl?: string;             // API基础URL（OpenAI兼容必需）
  model?: string;               // 模型名称
  
  // 统一参数（所有模型应支持）
  width?: number;               // 图像宽度
  height?: number;              // 图像高度
  steps?: number;               // 生成步数
  guidance?: number;            // 引导强度
  negativePrompt?: string;      // 负面提示词
  seed?: number;                // 随机种子
  
  // 扩展配置（特定模型专用）
  [key: string]: any;
}
```

**配置验证流程**
```typescript
async function generateImageWith[YourModel](altText: string, imageConfig: any): Promise<string> {
  console.log(`🚀 [YourModel] Starting image generation for: ${altText.substring(0, 50)}`);
  
  // 1. 配置获取和验证
  let modelConfig;
  
  if (imageConfig.yourModelSpecificConfig) {
    // 支持统一配置中的完整配置
    modelConfig = {
      apiKey: imageConfig.apiKey || imageConfig.yourModelSpecificConfig.apiKey,
      baseUrl: imageConfig.yourModelSpecificConfig.baseUrl,
      model: imageConfig.yourModelSpecificConfig.model || 'default-model',
      // 其他特定参数...
    };
  } else {
    // 降级到基本配置
    if (!imageConfig.apiKey) {
      throw new Error('YourModel requires API key. Please configure it in the modal.');
    }
    modelConfig = {
      apiKey: imageConfig.apiKey,
      baseUrl: imageConfig.baseUrl || 'https://default-api-url.com',
      model: imageConfig.model || 'default-model',
      // 使用默认参数...
    };
  }

  // 2. 验证必需配置
  if (!modelConfig.apiKey) {
    console.error('❌ [YourModel] Missing API key');
    throw new Error('YourModel API key is required');
  }
  
  // 记录配置用于调试
  console.log('🔧 [YourModel] Configuration validated:', {
    hasApiKey: !!modelConfig.apiKey,
    hasBaseUrl: !!modelConfig.baseUrl,
    model: modelConfig.model
  });
```

### 1.2 必须遵守的配置规则

**❗ 强制要求：**
1. **必须支持基础配置**：仅有 apiKey 的最简配置必须可用
2. **必须记录详细日志**：配置验证、API调用、错误信息都要记录
3. **必须提供清晰错误信息**：用户可理解的错误提示，不是技术细节
4. **必须处理缺失参数**：提供合理的默认值或明确的错误提示

---

## 阶段二：智能参数转换（核心特色）

### 2.1 参数映射系统

**智能参数转换原则**
```typescript
// 根据模型特性进行智能参数转换
function buildRequestBody(altText: string, modelConfig: any) {
  let requestBody;
  
  // 检查模型特殊处理需求
  if (isSpecialModel(modelConfig.model)) {
    // 特殊模型的智能参数映射
    let enhancedPrompt = altText;
    
    // 1. Guidance -> 提示词强度增强
    if (modelConfig.guidance > 10) {
      enhancedPrompt += ', extremely detailed, ultra-precise, highly accurate';
    } else if (modelConfig.guidance > 7.5) {
      enhancedPrompt += ', highly detailed, precise, well-defined';
    } else if (modelConfig.guidance < 5) {
      enhancedPrompt += ', creative interpretation, artistic freedom';
    }
    
    // 2. 尺寸 -> 质量提示自动添加
    const isHighRes = modelConfig.width >= 1024 || modelConfig.height >= 1024;
    const isUltraHighRes = modelConfig.width >= 1280 || modelConfig.height >= 1280;
    
    if (isUltraHighRes) {
      enhancedPrompt += ', ultra high resolution, 4K quality, extremely sharp';
    } else if (isHighRes) {
      enhancedPrompt += ', high resolution, sharp details, crisp image';
    }
    
    // 3. 宽高比 -> 构图建议自动生成
    const aspectRatio = modelConfig.width / modelConfig.height;
    if (aspectRatio > 1.5) {
      enhancedPrompt += ', wide landscape composition, panoramic view';
    } else if (aspectRatio < 0.75) {
      enhancedPrompt += ', tall portrait composition, vertical framing';
    } else {
      enhancedPrompt += ', balanced square composition, centered framing';
    }
    
    // 4. 负面提示 -> 正面增强转换 (创新核心!)
    if (modelConfig.negativePrompt) {
      const negativeTerms = modelConfig.negativePrompt.toLowerCase();
      if (negativeTerms.includes('blur') || negativeTerms.includes('low quality')) {
        enhancedPrompt += ', crystal clear, high quality, sharp focus';
      }
      if (negativeTerms.includes('distort') || negativeTerms.includes('deform')) {
        enhancedPrompt += ', perfect proportions, accurate anatomy, clean lines';
      }
      if (negativeTerms.includes('dark') || negativeTerms.includes('shadow')) {
        enhancedPrompt += ', well-lit, bright lighting, clear visibility';
      }
    }
    
    // 添加通用质量增强
    enhancedPrompt += ', professional quality, detailed rendering';
    
    // 特殊模型请求体 - 只支持部分参数
    requestBody = {
      prompt: enhancedPrompt,
      steps: Math.min(modelConfig.steps, 8) // 某些模型有步数限制
    };
    
  } else {
    // 标准模型使用完整参数集
    requestBody = {
      prompt: altText + ', high quality, professional, detailed',
      num_steps: modelConfig.steps,
      guidance: modelConfig.guidance,
      width: modelConfig.width,
      height: modelConfig.height
    };
    
    // 添加可选参数
    if (modelConfig.negativePrompt) {
      requestBody.negative_prompt = modelConfig.negativePrompt;
    }
    if (modelConfig.seed !== null && modelConfig.seed !== undefined) {
      requestBody.seed = modelConfig.seed;
    }
  }
  
  return requestBody;
}
```

### 2.2 参数转换规则

**❗ 核心规则：**
1. **智能增强原则**：将简单参数转换为模型理解的复杂指令
2. **负面转正面**：将负面提示词转换为正面的质量增强
3. **模型适配**：根据不同模型的能力限制调整参数
4. **用户意图保持**：增强的同时保持用户原始意图

---

## 阶段三：API调用与响应处理（必须实现）

### 3.1 统一HTTP调用模式

```typescript
// API调用标准流程
const apiUrl = buildApiUrl(modelConfig);
console.log('🚀 [YourModel] Making API request to:', apiUrl);
console.log('📝 [YourModel] Request body:', requestBody);

const response = await fetch(apiUrl, {
  method: 'POST',
  headers: {
    'Authorization': `Bearer ${modelConfig.apiKey}`,
    'Content-Type': 'application/json'
  },
  body: JSON.stringify(requestBody)
});

console.log('📡 [YourModel] Response status:', response.status, response.statusText);
```

### 3.2 错误处理映射

**状态码精确映射（必须实现）**
```typescript
if (!response.ok) {
  const errorText = await response.text();
  let errorMessage = `YourModel API call failed: ${response.status}`;
  
  console.error('❌ [YourModel] API call failed:', {
    status: response.status,
    statusText: response.statusText,
    errorText: errorText.substring(0, 200)
  });
  
  switch (response.status) {
    case 401:
      errorMessage = 'Invalid API key. Please check your YourModel API token.';
      break;
    case 403:
      errorMessage = 'Access forbidden. Please check your API token permissions.';
      break;
    case 429:
      errorMessage = 'Rate limit exceeded. Please wait and try again.';
      break;
    case 400:
      errorMessage = 'Invalid request. Please check your configuration.';
      break;
    default:
      errorMessage += ` - ${errorText}`;
  }
  
  console.error('❌ [YourModel] Final error message:', errorMessage);
  throw new Error(errorMessage);
}
```

---

## 阶段四：智能图片转换系统（核心功能）

### 4.1 响应格式智能识别

**多格式响应处理（必须实现）**
```typescript
// 根据模型特性处理不同响应格式
if (isJsonResponseModel(modelConfig.model)) {
  // JSON响应格式智能解析
  console.log('📄 [YourModel] Processing JSON response');
  
  const jsonResponse = await response.json();
  console.log('✅ [YourModel] Response structure:', Object.keys(jsonResponse));
  
  // 多层级数据提取策略
  let base64Data;
  if (jsonResponse.result?.image) {
    base64Data = jsonResponse.result.image;
  } else if (jsonResponse.data?.[0]?.url) {
    // 某些API返回URL而非base64
    return jsonResponse.data[0].url;
  } else if (jsonResponse.image) {
    base64Data = jsonResponse.image;
  } else if (typeof jsonResponse === 'string') {
    base64Data = jsonResponse;
  } else {
    console.error('❌ [YourModel] Unexpected response format:', jsonResponse);
    throw new Error('Unexpected response format from YourModel');
  }
  
  // 确保base64数据格式正确
  if (!base64Data || typeof base64Data !== 'string') {
    throw new Error('Invalid base64Data received from YourModel');
  }
  
  // 智能格式标准化
  if (base64Data.startsWith('data:image/')) {
    console.log('✅ [YourModel] Image generated successfully (data URL format)');
    return base64Data;
  } else {
    console.log('✅ [YourModel] Image generated successfully (base64 format)');
    return `data:image/png;base64,${base64Data}`;
  }
  
} else {
  // 二进制响应格式智能转换
  console.log('🔢 [YourModel] Processing binary response');
  
  const arrayBuffer = await response.arrayBuffer();
  const base64Data = Buffer.from(arrayBuffer).toString('base64');
  
  console.log('✅ [YourModel] Image generated successfully, size:', arrayBuffer.byteLength, 'bytes');
  
  return `data:image/png;base64,${base64Data}`;
}
```

### 4.2 图片转换规则

**❗ 强制标准：**
1. **统一返回格式**：所有模型必须返回 `data:image/[type];base64,[data]` 格式
2. **智能格式检测**：自动识别 JSON 或二进制响应
3. **多层提取策略**：按优先级尝试不同字段提取图片数据
4. **格式标准化**：自动补全缺失的 data URL 前缀

---

## 阶段五：任务编排管理系统（必须集成）

### 5.1 三阶段处理流程

**所有图像生成必须遵循的流程：**

```typescript
// 阶段1: HTML结构生成 (0-33%)
await processStage1(env, jobId, requestData)

// 阶段2: 图片生成和处理 (33-80%) 
await processStage2(env, jobId, requestData, htmlStructure)
// 你的模型在这个阶段被调用

// 阶段3: HTML优化与验证 (80-100%)
await processStage3(env, jobId, requestData, processedHTML)
```

### 5.2 状态跟踪集成

**必须更新的状态信息：**
```typescript
// 在图片生成过程中更新进度
async function generateSingleImage(altText: string, imageConfig: any, ...) {
  // ... 配置验证
  
  try {
    // 调用你的图片生成函数
    if (imageConfig.provider === 'your-model') {
      imageUrl = await generateImageWithYourModel(altText, imageConfig)
    }
    
    // 🆕 WordPress兼容性转换（如果需要）
    if (env && jobId && imageIndex !== undefined && needsWordPressConversion(imageUrl)) {
      console.log(`🔄 [WordPress] Converting image ${imageIndex + 1} to WordPress-compatible URL`)
      imageUrl = await convertToWordPressUrl(imageUrl, altText, jobId, imageIndex, env, baseUrl)
    }
    
    return imageUrl
    
  } catch (error) {
    // 重试机制
    retryCount++
    if (retryCount <= maxRetries) {
      await new Promise(resolve => setTimeout(resolve, 1000 * retryCount))
    } else {
      // 多层兜底：Unsplash -> Pollinations -> Placeholder
      // ... 兜底逻辑
    }
  }
}
```

---

## 阶段六：存储服务集成（必须遵循）

### 6.1 双层存储架构

**D1 + KV 存储模式：**
```typescript
// D1 SQLite: 持久化主存储
await env.DB.prepare(`
  INSERT INTO async_jobs (id, status, request_data, html_structure, created_at)
  VALUES (?, ?, ?, ?, datetime('now'))
`).bind(jobId, 'pending', JSON.stringify(requestData), htmlStructure).run()

// KV 存储: 实时状态更新
await env.JOBS.put(jobId, JSON.stringify({
  status: 'processing',
  currentStep: 2,
  steps: [详细进度信息],
  htmlStructure: 实时HTML内容,
  progress: 67,
  updatedAt: new Date().toISOString()
}))
```

### 6.2 数据分层策略

**❗ 存储规则：**
- **D1**: 任务创建、最终状态、历史记录
- **KV**: 实时进度、临时状态、轮询优化
- **R2**: 大文件存储（如果需要）

---

## 阶段七：HTML集成图片转换（可选功能）

### 7.1 base64转换系统

```typescript
// 可选的base64转换功能（用户可控）
if (requestData.convertImagesToBase64) {
  console.log(`🖼️ [${jobId}] Converting images to base64 format`)
  await updateJobProgress(env, jobId, 'processing', 3, '转换图片为base64格式', 95, finalHTML)
  finalHTML = await convertImagesToBase64(finalHTML)
}
```

### 7.2 智能转换处理

```typescript
async function convertImagesToBase64(html: string): Promise<string> {
  // 1. 正则表达式智能提取所有img标签
  const imgRegex = /<img[^>]+src="([^"]+)"[^>]*>/gi
  const matches = [...html.matchAll(imgRegex)]
  
  for (let i = 0; i < matches.length; i++) {
    const imageUrl = matches[i][1]
    
    // 2. 智能跳过已处理的图片
    if (imageUrl.startsWith('data:')) {
      continue
    }
    
    // 3. 错误容错处理 - 不中断整体流程
    try {
      const base64Image = await fetchImageAsBase64(imageUrl)
      // 替换处理...
    } catch (error) {
      console.warn(`⚠️ Failed to convert image: ${error.message}`)
      // 保持原始 URL，继续处理其他图片
    }
  }
}
```

---

## 📋 开发检查清单

### 必须实现的功能 ✅

- [ ] **配置验证系统**：支持统一配置和降级配置
- [ ] **详细日志记录**：所有关键步骤都有日志
- [ ] **错误处理映射**：HTTP状态码精确映射为用户友好信息
- [ ] **响应格式处理**：支持JSON和二进制响应智能识别
- [ ] **统一返回格式**：返回标准的 data URL 格式
- [ ] **重试降级机制**：API失败时的多层兜底策略

### 推荐实现的功能 🌟

- [ ] **智能参数转换**：将通用参数转换为模型最优效果
- [ ] **负面转正面**：负面提示词转换为正面质量增强
- [ ] **模型特殊处理**：根据模型特性调整参数和处理逻辑
- [ ] **WordPress兼容**：平台兼容性转换接口
- [ ] **性能优化**：缓存、并发控制等优化措施

### 可选扩展功能 💡

- [ ] **多模型支持**：单个provider支持多个子模型
- [ ] **批量处理**：支持批量图片生成
- [ ] **自定义后处理**：图片后处理管道
- [ ] **成本控制**：API调用成本跟踪和限制

---

## 🚨 务必遵守的规则

### 1. **接口一致性**
- 所有图片生成函数必须有相同的签名
- 返回格式必须是标准的 data URL
- 错误处理必须抛出有意义的错误信息

### 2. **用户体验**
- 必须提供详细的进度反馈
- 错误信息必须用户友好，不是技术细节
- 不能因为单个模型失败而影响整体服务

### 3. **性能要求**
- API调用必须有超时控制
- 必须实现重试机制
- 大文件处理要考虑内存限制

### 4. **安全规范**
- API密钥不能记录到日志
- 敏感信息必须妥善处理
- 输入参数必须验证和清理

### 5. **扩展性设计**
- 新模型不能破坏现有功能
- 配置结构要向下兼容
- 预留扩展接口便于未来升级

---

## 🔧 调试和测试指南

### 日志标准
```typescript
console.log('🚀 [ModelName] Starting image generation')  // 开始
console.log('🔧 [ModelName] Configuration validated')    // 配置验证
console.log('📝 [ModelName] Request body:', requestBody) // 请求详情
console.log('📡 [ModelName] Response status:', status)   // 响应状态
console.log('✅ [ModelName] Image generated successfully') // 成功完成
console.error('❌ [ModelName] Error:', error.message)    // 错误信息
```

### 测试用例
- 基础配置测试：仅有apiKey的最小配置
- 完整配置测试：所有参数都设置的配置
- 错误场景测试：无效apiKey、网络错误、格式错误等
- 边界值测试：超大尺寸、极值参数等

---

## 📖 参考实现

请参考现有的 `generateImageWithCloudflareWorkersAI` 函数作为标准实现，它完整展示了所有必需的功能和最佳实践。

新模型的实现应该按照相同的模式和质量标准进行开发，确保整个系统的一致性和可靠性。